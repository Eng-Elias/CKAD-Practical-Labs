# 12.7 Configuring a ServiceAccount

## Introduction to ServiceAccount Configuration

ServiceAccounts in Kubernetes are essential for managing the identity of processes running in Pods. This section covers advanced configuration options and best practices for working with ServiceAccounts.

## Creating and Managing ServiceAccounts

### Basic ServiceAccount Creation
```yaml
# serviceaccount-basic.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-serviceaccount
  namespace: default
```

### Creating a ServiceAccount with Annotations
```yaml
# serviceaccount-annotated.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-annotated-sa
  namespace: default
  annotations:
    example.com/description: "Service account for the production API"
    iam.gke.io/gcp-service-account: "my-service-account@my-project.iam.gserviceaccount.com"
```

### Managing Image Pull Secrets
```yaml
# serviceaccount-imagepullsecret.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-app-sa
  namespace: default
imagePullSecrets:
- name: my-registry-secret
```

## Automounting ServiceAccount Tokens

### Default Behavior
- By default, Kubernetes automatically mounts a ServiceAccount token at:
  ```
  /var/run/secrets/kubernetes.io/serviceaccount/token
  ```

### Disabling Automatic Token Mounting
#### At the Pod Level
```yaml
# pod-disable-automount.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  automountServiceAccountToken: false
  containers:
  - name: my-container
    image: nginx
```

#### At the ServiceAccount Level
```yaml
# serviceaccount-disable-automount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: no-token-sa
  annotations:
    kubernetes.io/enforce-mountable-secrets: "false"
```

## Using Multiple ServiceAccounts

### Assigning Multiple ServiceAccounts to a Pod
```yaml
# pod-multiple-serviceaccounts.yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-sa-pod
spec:
  serviceAccountName: primary-sa
  containers:
  - name: app-container
    image: my-app
    volumeMounts:
    - name: secondary-token
      mountPath: /var/run/secrets/tokens/secondary
      readOnly: true
  volumes:
  - name: secondary-token
    projected:
      sources:
      - serviceAccountToken:
          path: token
          expirationSeconds: 7200
          audience: vault
```

## Token Management

### Creating Manual Tokens
```yaml
# manual-token.yaml
apiVersion: v1
kind: Secret
metadata:
  name: manual-token
  annotations:
    kubernetes.io/service-account.name: my-serviceaccount
type: kubernetes.io/service-account-token
data:
  # The token will be generated by the controller
  token: ""
```

### Using TokenRequest API
```yaml
# token-request.yaml
apiVersion: v1
kind: Pod
metadata:
  name: token-request-pod
spec:
  containers:
  - name: my-container
    image: nginx
    volumeMounts:
    - name: token-volume
      mountPath: /var/run/secrets/tokens
  volumes:
  - name: token-volume
    projected:
      sources:
      - serviceAccountToken:
          path: token
          expirationSeconds: 600
          audience: api
```

## ServiceAccount Impersonation

### Impersonating a ServiceAccount
```bash
# Impersonate a ServiceAccount
kubectl get pods --as=system:serviceaccount:default:my-serviceaccount

# Impersonate with specific groups
kubectl get pods --as=system:serviceaccount:default:my-serviceaccount \
  --as-group=system:authenticated \
  --as-group=system:serviceaccounts
```

## Best Practices for ServiceAccounts

### 1. Least Privilege
- Create dedicated ServiceAccounts for each application
- Assign minimal necessary permissions
- Regularly audit and clean up unused ServiceAccounts

### 2. Security
- Use short-lived tokens when possible
- Rotate ServiceAccount tokens regularly
- Monitor ServiceAccount usage

### 3. Naming Conventions
- Use descriptive names
- Include the application name in the ServiceAccount name
- Use consistent naming across environments

## Practical Example: Complete Application Setup

### 1. Create a Namespace
```bash
kubectl create namespace my-application
```

### 2. Create a ServiceAccount
```yaml
# serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-application
  namespace: my-application
  labels:
    app: my-application
```

### 3. Create RBAC Resources
```yaml
# rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: my-application-role
  namespace: my-application
rules:
- apiGroups: [""]
  resources: ["pods", "services", "configmaps"]
  verbs: ["get", "list", "watch", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: my-application-binding
  namespace: my-application
subjects:
- kind: ServiceAccount
  name: my-application
  namespace: my-application
roleRef:
  kind: Role
  name: my-application-role
  apiGroup: rbac.authorization.k8s.io
```

### 4. Deploy the Application
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-application
  namespace: my-application
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-application
  template:
    metadata:
      labels:
        app: my-application
    spec:
      serviceAccountName: my-application
      containers:
      - name: my-application
        image: my-application:latest
        ports:
        - containerPort: 8080
        env:
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
```

## Troubleshooting ServiceAccounts

### Common Issues

#### 1. Permission Denied
```bash
# Check if the ServiceAccount exists
kubectl get serviceaccount my-serviceaccount -n my-namespace

# Check Role and RoleBinding
kubectl get role,rolebinding -n my-namespace

# Check effective permissions
kubectl auth can-i get pods --as=system:serviceaccount:my-namespace:my-serviceaccount
```

#### 2. Token Mount Issues
```bash
# Check if token is mounted
kubectl exec -it my-pod -- ls -la /var/run/secrets/kubernetes.io/serviceaccount/

# Check Pod spec
kubectl get pod my-pod -o yaml | grep serviceAccount
```

#### 3. Image Pull Secrets
```bash
# Check if image pull secret is attached to the ServiceAccount
kubectl get serviceaccount my-serviceaccount -o yaml

# Verify the secret exists
kubectl get secret my-registry-secret
```

## Advanced Topics

### 1. Projected ServiceAccount Tokens
```yaml
# projected-token.yaml
apiVersion: v1
kind: Pod
metadata:
  name: projected-token-pod
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: kube-api-access
      mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      readOnly: true
  volumes:
  - name: kube-api-access
    projected:
      defaultMode: 420
      sources:
      - serviceAccountToken:
          path: token
          expirationSeconds: 3600
          audience: api
      - configMap:
          name: kube-root-ca.crt
          items:
            - key: ca.crt
              path: ca.crt
      - downwardAPI:
          items:
            - path: namespace
              fieldRef:
                fieldPath: metadata.namespace
```

### 2. Using OIDC with ServiceAccounts
```yaml
# oidc-serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: oidc-serviceaccount
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/my-oidc-role
```

## Summary

Configuring ServiceAccounts properly is crucial for securing your Kubernetes workloads. Key points to remember:

1. **Use dedicated ServiceAccounts** for different applications
2. **Follow the principle of least privilege** when assigning permissions
3. **Manage tokens securely** using projected volumes and TokenRequest API
4. **Regularly audit** ServiceAccount usage and permissions
5. **Use annotations** for cloud provider integrations and metadata
6. **Monitor and rotate** ServiceAccount tokens regularly

By following these practices, you can ensure that your applications have the minimal necessary permissions while maintaining a strong security posture in your Kubernetes cluster.
